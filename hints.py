# # Строки и индексация строк
# # строки можно складовать и умонжать
# name = 'Hello '
# name2 = 'World!'
# print(name + name2)
# print(name * 3)
# # строки можно выводить по буквенно
# print(name[0])
# # срезы
# print(name[0:1:1])  # первое число начало, втовая цифра конец, третье чесло шаг
# print(name[::-1])  # развернет текст
#
# # Динамическая типизация
#
# # Разные типы данных нельзя кладовать
#
# str_ = 'text'
# print(type(str_))
# int_ = 5
# print(type(int_))
# float_ = 1.3
# print(type(float_))
# bool_ = True, False
# print(type(bool_))
#
# # Методы строк
#
# # user_input = input('Текст:')
# # print(type(user_input))
#
# # x, y = map(int, input('Text: ').split())#функция map применяется для преобразования каждой строки
# # из списка в целое число с помощью функции int
# # input.split разделяет введенную строку на подстроки с использованием пробела в качестве разделителя
# # print(x, y)
#
# print(name.find('H'))  # find позволяет узнать индекс символа начинает очет с начала
# print(name.rfind('l'))  # начинает очет с конца
# print(name.replace('H', 'M'))  # меняет символ на любой
# print(name.upper())  # делает все буквы заглавными
# print(name.lower())  # делает все буквы в нижний регистр
# print(name.isalpha())  # проверяет строку на буквы
# print(name.isnumeric())  # проверяет строку на цифры
#
# # Списки, кортеж, словарь, множество
#
# food = ['apple', 'coconut', 'banana']  # список
# print(food[0])  # можно перебрать спискок по индексу
# food[0] = 'peach'  # можно менять список
# food.append('dfgfd')  # добовляет в конец списка новый
# food.extend('string')  # добовляет в конец по каждому символу отдельно
# food.remove('banana')  # убирает из списка
# print('apple' in food)  # in проверяет есть ли в списке этот символ
# print('coconut' not in food)  # есть отсутствует ли некий элемент в списке
# print(food[0:2:2])  # можно делать срезы
#
# tuple_ = 1, 2, 3, 4  # кортеж можно в () можно без
# # кортеж относится к неизменяемым типам данных, тем не менее внутри он может содержать изменяемые типы
# # можно индексировать, складовать и умножать можно
#
# dict_ = {'слон': 'большой'}  # словарь ключ значение, клюз не изменяемый значение можно поменять
# # слаживать и умножать нельзя, можно сравнивать
# print(dict_['слон'])  # можно по ключу вызвать значение
# print(dict_.get('жираф', 'высокий'))  # добовляет новый ключ и значение
# print(dict_.setdefault('кот', 'мурзик'))  # возвращает значение, соответствующее ключу. Но если указанный ключ
# # отсутствует в словаре,
# # то он вставит его в словарь со значением default и покажет это значение default
#
#
# # Множество (set) – неупорядоченный набор уникальных элементов
#
# my_set = {1, 2, 3, 4}
# # добавление элемента (.add)
# # удаление элемента (.pop(), .discard())
# # обновление .update()
#
# # Условный оператор if
#
# namber = 10 > 4
#
# if namber >= 10:
#     print('ok')
# if namber < 10:
#     print('no')
#
# # Цикл while
#
# # while 1 > 0:
# #     numbers1 = int(input('Введите число: '))
# #     if numbers1 % 2 == 0:
# #         print('ok')
# #         continue  # пропускает выполнение всех оставшихся команды и переходит к следующему повторению цикла.
# #     else:
# #         print('no')
# #         break  # остонавливает цикл
# #
# # while True:  # что бы цикл почтоянно запрашивал нужно писать True
# #     some = input('Введите пароль: ')
# #     if some == 'qwerti':
# #         print('Правельно')
# #         break
# #     else:
# #         print('Не правельно')
#
# # Цикл for
#
# # как правило ее называют «i», «j» или «k». Обычно, в случае, когда цикл у нас встречается один раз мы называем ее «i».
# # После переменной мы пишем ключевое слово «in»
#
for i in 1, 2, 3, 4:
    print(i)

list_ = ['one', 'two', 'three']

for i in list_:
    if i == 'three':
        list_.remove(i)  # удаляет элемент
print(list_)

for i in range(len(list_)):  # Она возвращает нам последовательность чисел от 0 до числа, которое мы укажем в скобках
    print(list_[i])
print(list_)
print('hello')

